# coding=utf-8

# from Exploit.BaseExploit import *
from concurrent.futures import ThreadPoolExecutor
from Config import config
from Common.common import *


'''

1、遍历clear_task_list列表，循环其中的每个字典，先判断是否是self.target的目标，如果是的话继续进行下一步

2、探测规则：以ip + 遍历port的形式 进行访问探测是否存在，状态码为 broken_5里面的三种 200 206 ....

3、最后每个IP扫描完之后都作为字典进行保存到列表中，最后用write_file进行写入完成

'''


class AliveScan(object):
    def __init__(self, target, clear_task_list):
        super().__init__()
        self.source = "Alive scan"
        self.headers = {}
        self.ports = {}
        self.target = target
        self.clear_task_list = clear_task_list
        self.alivescanlist = list()

    # 实现拼接url + port的功能
    def gen_url_list(self, target, port):
        ports = set()

        # 这里进行取要扫描的端口类型
        if port in {'default', 'small', 'medium', 'large', 'service'}:
            ports = config.ports.get(port)

        # 生成URL
        url_list = []
        target = target.strip()

        # 这里进行端口和url的拼接，最后返回一个列表
        for port in ports:
            url = Common_url_by_port(target, int(port))
            if isinstance(url, list):
                url_list += url
            else:
                url_list.append(url)
        
        print(url_list)
        return url_list

    def write_file(self, web_lists, target, page):
        pass

    def exploit(self, url_list):
        # gen_url_list之后 就需要进行requests模块进行请求来进行探测是否存活
        try:
            r = requests.get(url, timeout=config.timeout, headers=self.get_headers(), verify=config.verify_ssl, allow_redirects=config.allow_redirects)
            text = r.content.decode(encoding=chardet.detect(r.content)['encoding'])
            title = self.get_title(text).strip().replace('\r', '').replace('\n', '')
            status = r.status_code
            size = FileUtils.sizeHuman(len(r.text))
            if status in config.ignore_status_code:
                raise Exception
            self.output.statusReport(url, status, size, title)
            result = [title, url, str(status), size, '']
            self.alive_result_list.append(result)
            return r, text
        except Exception as e:
            return e

        # self.alivescanlist进行保存
        pass

    def main(self):
        '''
        测试数据:
            [
                {'subdomain': '', 'ips': '183.136.237.194', 'port': ['8443', '11680', '9443'], 'target': 'ip'},
                {'subdomain': 'mzw.zj.gov.cn', 'ips': '183.136.237.220', 'port': None, 'target': 'webdomain'}
                {'subdomain': 'yxapi.nbcc.cn', 'ips': '60.190.19.102', 'port': None, 'target': 'subdomain'}
            ]
        '''
        p = ThreadPoolExecutor(10)
        for i in self.clear_task_list:
            # 先判断要扫描的目标是否是子域名下的
            if i['target'] == 'subdomain':
                # 再去获得它当前域名解析的ip
                temp_ip = i['ips']
                a_url_list = self.gen_url_list(temp_ip, 'small_ports')  # 默认扫描的常用的web服务的端口
                p.submit(self.exploit, a_url_list)

test_list = [
                {'subdomain': '', 'ips': '183.136.237.194', 'port': ['8443', '11680', '9443'], 'target': 'ip'},
                {'subdomain': 'mzw.zj.gov.cn', 'ips': '183.136.237.220', 'port': None, 'target': 'webdomain'},
                {'subdomain': 'yxapi.nbcc.cn', 'ips': '60.190.19.102', 'port': None, 'target': 'subdomain'}
            ]

print(111111111)
alivescan = AliveScan('nbcc.cn',test_list).main()








