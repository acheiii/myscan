# coding=utf-8
import re
from urllib.parse import urlparse

from colorama import Fore
from tqdm import tqdm

from exploit.web import BaseScript
from core.MyEnums import BugType, BugLevel
from core.MyAsyncHttp import *


class Script(BaseScript):
    name = 'Backup'

    def __init__(self, target, session):
        super().__init__()
        # 漏洞目标
        self.target = target
        # 漏洞等级
        self.bugLevel = BugLevel.HIGH
        # 类型
        self.bugType = BugType.BACKUP
        # 编号
        self.bugNumber = ''
        # 来源
        self.refer = ''
        # 特定路径判断
        self.detectPathList = list(self.generateBackupPath(target))
        # exec
        self.execPathList = []
        # 进度条
        self.session = session
        # 相关信息
        self.info = ''

    def generateBackupPath(self, target):
        # @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske

        def isIP(url):
            p = re.compile(r'\d+.\d+.\d+:?\d?')
            if p.match(url):
                return True
            else:
                return False

        ipFlag = isIP(target)
        subdomains = []
        if ipFlag is False:
            if 'http://' in target or 'https://' in target:
                subdomains = urlparse(target).netloc.split('.')[:-1]
            else:
                subdomains = urlparse(f'http://{target}/').netloc.split('.')[:-1]
        #  @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske @ske
        filePrefixs = list(set(["www", "wwwroot", "backup", "web"] + subdomains))
        fileSuffixs = ["zip", "rar", "tar.gz"]
        for filePrefix in filePrefixs:
            for fileSuffix in fileSuffixs:
                yield '/' + filePrefix + '.' + fileSuffix

    async def detect(self):
        try:
            for detectPath in self.detectPathList:
                url = f'http://{self.target}{detectPath}' if self.target.startswith(
                    ('http:', 'https:')) is False else f'{self.target}{detectPath}'
                async with self.session.get(url=url, headers=self.headers, allow_redirects=False, verify_ssl=False, timeout=self.reqTimeout) as response:
                    if response.status == 200 and \
                            'text/html' not in response.headers["Content-Type"] and \
                            'text/plain' not in response.headers["Content-Type"] and \
                            'application/json' not in response.headers["Content-Type"] and\
                            'image/jpeg' not in response.headers["Content-Type"]:
                        tqdm.write(Fore.RED + '[{}] {}'.format('Backup', url))
                        self.flag = True
                        return {'name': 'Backup', 'url': url, 'software': 'Backup'}
        except Exception:
            pass

    async def attack(self, semaphore, pbar):
        async with semaphore:
            a = await self.detect()
            if a is not None:
                self.vulList.append(a)
        pbar.update(1)
        return self.vulList


if __name__ == '__main__':
    sem = asyncio.Semaphore(500)
    sc = Script('testjwt.com', 1)
    l = asyncio.get_event_loop()
    l.run_until_complete(sc.attack(sem))

