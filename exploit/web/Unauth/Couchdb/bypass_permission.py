# # coding=utf-8
# # @Author   : zpchcbd HG team
# # @Time     : 2021-08-27 18:36
#
# from colorama import Fore
# from tqdm import tqdm
#
# from exploit.web import BaseScript
# from core.MyEnums import *
# from core.MyAsyncHttp import *
#
#
# # fofa: app="APACHE-CouchDB" && country="CN"
# # python batch.py -m exploit.web.Unauth.Couchdb.Unauth -cs -fs "app=\"APACHE-CouchDB\" && country=\"CN\""
#
# class Script(BaseScript):
#     name = 'Couchdb'
#
#     def __init__(self, target, session):
#         super().__init__()
#         # 漏洞目标
#         self.target = target
#         # 漏洞等级
#         self.bugLevel = BugLevel.HIGH
#         # 类型
#         self.bugType = BugType.BYPASSPERMISSION
#         # 编号
#         self.bugNumber = 'CVE-2017-12635'
#         # 来源
#         self.refer = ''
#         # 特定路径判断
#         self.detectPathList = ['/_config']
#         # exec
#         self.execPathList = ['/execPath']
#         # session
#         self.session = session
#         # 相关信息
#         self.info = 'version < 1.7.0 and < 2.1.1'
#
#     async def detect(self):
#         try:
#             for detectPath in self.detectPathList:
#                 url = f'http://{self.target}{detectPath}' if self.target.startswith(
#                     ('http:', 'https:')) is False else f'{self.target}{detectPath}'
#                 async with self.session.get(url=url, headers=self.headers, timeout=self.reqTimeout, verify_ssl=False) as response:
#                     if response is not None:
#                         text = await response.text()
#                         await asyncio.sleep(2)
#                         if 'couch' in text or '{"error":"unauthorized","reason":"Authentication required."}' in text:
#                             self.flag = True
#                             tqdm.write(Fore.RED + '[{}] {}'.format('Couchdb Unauth', url))
#                             return {'name': 'Couchdb Unauth', 'url': url, 'software': 'Couchdb'}
#         except Exception:
#             return None
#
#     # async def exec(self):
#     #     try:
#     #         async with aiohttp.ClientSession() as session:
#     #             for execPath in self.execPathList:
#     #                 url = f'http://{self.target}{execPath}' if self.target.startswith(
#     #                     ('http:', 'https:')) is False else f'{self.target}{execPath}'
#     #                 async with session.get(url=url, timeout=self.reqTimeout, verify_ssl=False) as response:
#     #                     if response is not None:
#     #                         text = await response.text()
#     #                         await asyncio.sleep(2)
#     #                         if 'something about keywords in the web' in text:
#     #                             tqdm.write(Fore.RED + '[{}] {}'.format('Couchdb Unauth', url))
#     #                             return {'name': 'Couchdb Unauth', 'url': url, 'software': 'Couchdb'}
#     #     except Exception:
#     #         return None
#
#     async def attack(self, semaphore, pbar):
#         async with semaphore:
#             a = await self.detect()
#             if a is not None:
#                 self.vulList.append(a)
#             if self.flag:
#                 b = await self.exec()
#                 if b is not None:
#                     self.vulList.append(b)
#         pbar.update(1)
#         return self.vulList
#
#
# if __name__ == '__main__':
#     pass
#     # import requests
#     # import hashlib
#     #
#     # resp = requests.get('https://50.84.113.154:8443/favicon.ico', verify=False)
#     # if resp.status_code == 200:
#     #     m1 = hashlib.md5()
#     #     m1.update(resp.content)
#     #     theMD5 = m1.hexdigest()
#     #     print(theMD5)
#     #
#     # semaphore = asyncio.Semaphore(500)
#     # sc = Script('61.150.65.205:9999', 1)
#     # l = asyncio.get_event_loop()
#     # l.run_until_complete(sc.attack(semaphore))
