# coding=utf-8
# @Author   : zpchcbd HG team
# @Time     : 2021-09-11 15:33
#
# from async_timeout import timeout
# from colorama import Fore
# from tqdm import tqdm
#
# from exploit.web import BaseScript
# from core.MyEnums import *
# from core.MyAsyncHttp import *
#
#
# # app=\"百度-UEditor\" && country=\"CN\"
# # python batch.py -m exploit.web.Editor.ueditor -cs -fs "app=\"百度-UEditor\" && country=\"CN\""
#
# class Script(BaseScript):
#     name = 'webUploader'
#
#     def __init__(self, target, pbar, semaphore):
#         super().__init__()
#         # 漏洞目标
#         self.target = target
#         # 漏洞等级
#         self.bugLevel = BugLevel.HIGH
#         # 类型
#         self.bugType = BugType.UPLOADFILE
#         # 编号
#         self.bugNumber = ''
#         # 来源
#         self.refer = ''
#         # 特定路径判断
#         self.detectPathList = ['/webuploader-0.1.5/server/preview.php', '/server/preview.php', '/webuploader/server/preview.php'
#                                , '/webuploader/0.1.5/server/preview.php']
#         # exec
#         self.execPathList = ['/ueditor/net/controller.ashx']
#         # 进度条
#         self.pbar = pbar
#         # 信号量
#         self.semaphore = semaphore
#         # 相关信息
#         self.info = 'about net'
#
#     async def detect(self):
#         try:
#             async with self.semaphore:
#                 async with aiohttp.ClientSession() as session:
#                     for detectPath in self.detectPathList:
#                         url = f'http://{self.target}{detectPath}' if self.target.startswith(
#                             ('http:', 'https:')) is False else f'{self.target}{detectPath}'
#                         async with session.get(url=url, timeout=10, verify_ssl=False) as response:
#                             if response is not None:
#                                 text = await response.text()
#                                 if 'FineReport--Web Reporting Tool' in text:
#                                     self.flag = True
#                                     tqdm.write(Fore.RED + '[{}] {}'.format('FineReport', url))
#                                     return {'name': 'v2Conference Finger', 'url': url, 'software': 'v2Conference'}
#         except Exception:
#             return None
#
#     async def exec(self):
#         try:
#             async with self.semaphore:
#                 async with aiohttp.ClientSession() as session:
#                     for execPath in self.execPathList:
#                         url = f'http://{self.target}{execPath}' if self.target.startswith(
#                             ('http:', 'https:')) is False else f'{self.target}{execPath}'
#                         async with session.get(url=url, timeout=10, verify_ssl=False) as response:
#                             if response is not None:
#                                 text = await response.text()
#                                 if 'It works!' in text:
#                                     tqdm.write(Fore.RED + '[{}] {}'.format('FineReport', url))
#                                     self.flag = True
#                                     return {'name': 'v2Conference Getshell', 'url': url, 'software': 'v2Conference'}
#         except Exception:
#             return None
#
#     async def attack(self):
#         a = await self.detect()
#         if a is not None:
#             self.vulList.append(a)
#         if self.flag:
#             b = await self.exec()
#             if b is not None:
#                 self.vulList.append(b)
#         self.pbar.update(1)
#         return self.vulList
#
#
# if __name__ == '__main__':
#     pass
